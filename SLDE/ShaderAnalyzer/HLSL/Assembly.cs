using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;

namespace SLDE.ShaderAnalyzer.HLSL {

    public class Assembly : IAssembly {
        private static Regex splitInstructionMatchRegex = new Regex(
            @"^\s*" +                      // Matches whitespace at the beginning of the string
            @"(?<opcode>[a-zA-Z_][\w]*)" + // Matches an opcode keyword (has to start with a letter or _)
            @"(?:\s*[^\s\w]\w*)*\s+" +     // Matches any garbage in between that does not start with a valid word character
            @"(?<args>.*?(?=\s*(//|$)))",  // Matches the rest of the string up to any whitespace or comments
            RegexOptions.Compiled);

        private static Regex shaderModelMatchRegex = new Regex(@"^(?<type>[pvghdc]s)_(?<major>[1-9])_(?<minor>[0-9xabc][abc]?)$", RegexOptions.Compiled);
        private static Regex lineNumberMatchRegex = new Regex(@"^#line\s+(?<lineno>[0-9]+)\s*(""(?<filepath>[^""]*)""\s*)?$", RegexOptions.Compiled);

        private static string parsingFailedError = "assembly parsing failed";
        private static string noSignatureFoundError = "Parser: invalid assembly, no HLSL Shader Compiler signature found";
        private static string noShaderModelDirectiveFoundError = "Parser: invalid assembly, no shader model directive found";
        private static string unbalancedParensError = "Parser: invalid instruction, unbalanced parentheses encountered";
        private static string unknownOperatorError = "Parser: invalid instruction, unknown operator reached";
        private static string invalidArgumentsError = "Parser: invalid instruction, invalid amount of arguments expected";

        private bool compiledSuccessfully;

        private string[] assemblyLines;
        private string[] errorLines;

        private List<Instruction> instructions;
        private List<Notification> notifications;
        private List<CodeNotification> codeNotifications;
        private List<AssemblyNotification> assemblyNotifications;

        public Func<string, string> semanticTranslatorFunc;

        public Assembly(string[] assemblyLines, string[] errorLines) {
            this.assemblyLines = assemblyLines;
            this.errorLines = errorLines;

            instructions = new List<Instruction>();
            notifications = new List<Notification>();
            codeNotifications = new List<CodeNotification>();
            assemblyNotifications = new List<AssemblyNotification>();

            compiledSuccessfully = assemblyLines.Length != 0;
        }

        public void Parse() {
            if (compiledSuccessfully) {
                bool parsedSuccessfully = ParseAssembly();
                if (!parsedSuccessfully) {
                    notifications.Add(new Notification(NotificationType.Error, parsingFailedError));
                }
                compiledSuccessfully = parsedSuccessfully;
            }
        }

        public bool CompiledSuccessfully() {
            return compiledSuccessfully;
        }

        public string GetRawCompilerOutput() {
            return String.Join("\n", assemblyLines);
        }

        public string GetRawCompilerErrors() {
            return String.Join("\n", errorLines);
        }

        public IEnumerable<Instruction> GetInstructions() {
            return instructions;
        }

        public IEnumerable<Notification> GetNotifications() {
            return notifications;
        }

        public IEnumerable<CodeNotification> GetCodeNotifications() {
            return codeNotifications;
        }

        public IEnumerable<AssemblyNotification> GetAssemblyNotifications() {
            return assemblyNotifications;
        }

        private bool ParseAssembly() {
            int i = 0;
            bool hasSignature = false;

            for (; i < assemblyLines.Length; i++) {
                if (assemblyLines[i].StartsWith("// Generated by Microsoft (R) HLSL Shader Compiler")) {
                    hasSignature = true;
                    i++;
                    break;
                }
            }

            if (!hasSignature) {
                notifications.Add(new Notification(NotificationType.Error, noSignatureFoundError));
                return false;
            }

            // Setup for parsing
            RegisterTranslator rt = new RegisterTranslator(semanticTranslatorFunc);
            OpCodes opcodes = null;
            string sourcePath = null;
            int sourceLine = 0;
            int indentation = 0;

            for (; i < assemblyLines.Length; i++) {
                string line = assemblyLines[i];

                if (line.StartsWith("//")) {
                    // It's a header
                    rt.ReadHeaderLine(line);

                } else if (line.StartsWith("#")) {
                    // Line number directive perhaps?
                    Match match = lineNumberMatchRegex.Match(line);
                    if (match.Success) {
                        sourceLine = Int32.Parse(match.Groups["lineno"].Value);
                        if (match.Groups["filepath"].Success) {
                            sourcePath = match.Groups["filepath"].Value;
                        }
                    }

                } else if (opcodes == null) {
                    // We haven't encountered a shader model statement yet. We can't parse anything without it.
                    Match match = shaderModelMatchRegex.Match(line);
                    if (match.Success) {
                        if (Int32.Parse(match.Groups["major"].Value) > 3) {
//                            opcodes = OpCodes.DX11;
                        } else {
                            opcodes = OpCodes.DX9;
                        }
                    }

                } else {
                    // Could this be an instruction?
                    Match match = splitInstructionMatchRegex.Match(line);
                    Group opcodeGroup = match.Groups["opcode"];

                    if (opcodeGroup.Success) {
                        // It's an instruction, paaarse it!
                        string opcode = opcodeGroup.Value;

                        List<string> args;
                        if (!SplitArguments(match.Groups["args"].Value, out args)) {
                            notifications.Add(new AssemblyNotification(NotificationType.Error, unbalancedParensError, instructions.Count));
                            instructions.Add(new Instruction(InstructionType.Invalid, assemblyLines[i], null, sourcePath, sourceLine));
                            continue;
                        }

                        if (opcodes == OpCodes.DX9) {
                            // Dx9 has some useful stuff as def / dcl instructions
                            if (opcode.StartsWith("def")) {
                                rt.ReadConstantDefinition(opcode, args);
                                continue;
                            } else if (opcode.StartsWith("dcl")) {
                                rt.ReadDeclaration(opcode, args);
                                continue;
                            }
                        }

                        if (!opcodes.IsValidInstruction(opcode)) {
                            notifications.Add(new AssemblyNotification(NotificationType.Error, unknownOperatorError, instructions.Count));
                            instructions.Add(new Instruction(InstructionType.Invalid, assemblyLines[i], null, sourcePath, sourceLine));
                            continue;
                        }

                        // And beautify it!

                        for (int argIndex = 0; argIndex < args.Count; argIndex++) {
                            args[argIndex] = rt.Translate(args[argIndex]);
                        }

                        OpCodes.IOperator op;
                        string formattedLine;
                        try {
                            formattedLine = opcodes.FormatInstruction(opcode, args.ToArray(), out op);
                        } catch (FormatException) {
                            notifications.Add(new AssemblyNotification(NotificationType.Error, invalidArgumentsError, instructions.Count));
                            instructions.Add(new Instruction(InstructionType.Invalid, assemblyLines[i], null, sourcePath, sourceLine));
                            continue;
                        }

                        if (op.Dedents) {
                            indentation = (indentation > 0) ? indentation - 1 : 0;
                        }
                        formattedLine = new string('\t', indentation) + formattedLine;
                        if (op.Indents) {
                            indentation++;
                        }

                        List<Identifier> identifiers = null;
                        instructions.Add(new Instruction(op.Type, formattedLine, identifiers, sourcePath, sourceLine));
                        rt.ClearHeaderSection();
                    }
                }
            }

            if (opcodes == null) {
                notifications.Add(new Notification(NotificationType.Error, noShaderModelDirectiveFoundError));
                return false;
            }

            return false;
        }

        private bool SplitArguments(string args, out List<string> ary) {
            ary = new List<string>();
            int parensCounter = 0;
            int bracketCounter = 0;

            int start = 0;
            for (int i = 0; i < args.Length + 1; i++) {
                char c = i < args.Length ? args[i] : '\0';
                switch (c) {
                    case '(':
                        parensCounter++;
                        break;
                    case '[':
                        bracketCounter++;
                        break;
                    case ')':
                        parensCounter--;
                        break;
                    case ']':
                        bracketCounter--;
                        break;
                    case ',':
                        if (parensCounter == 0 && bracketCounter == 0) {
                            ary.Add(args.Substring(start, i - start).Trim());
                            start = i + 1;
                        }
                        break;
                    case '/':
                    case '\0':
                        ary.Add(args.Substring(start, i - start).Trim());
                        if (parensCounter == 0 && bracketCounter == 0) {
                            return true;
                        }
                        return false;
                }
            }
            return false;
        }
    }

}
